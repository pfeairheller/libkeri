//! libkeri configing module
//!
//! Configuration file management with multiple serialization formats

use rmp_serde as msgpack;
use serde::{Deserialize, Serialize};
use serde_cbor;
use serde_json;
use std::fs::File;
use std::io::{Read, Seek, SeekFrom, Write};
use std::path::{Path, PathBuf};

use crate::hio::errors::HioError;
use crate::hio::filing::{Filer, FilerContext};

/// Returns contextmanager generated by openFiler with Configer instance as default
/// and filed = true
pub fn open_cf(
    name: Option<String>,
    temp: Option<bool>,
    reopen: Option<bool>,
    clear: Option<bool>,
    filed: Option<bool>,
    base: Option<String>,
    fext: Option<String>,
    human: Option<bool>,
) -> Result<ConfigerContext, HioError> {
    let filed = filed.unwrap_or(true);
    let fext = fext.unwrap_or_else(|| "json".to_string());
    let human = human.unwrap_or(true);

    let configer = Configer::new(
        name,
        base,
        temp,
        None,
        None,
        reopen,
        clear,
        None,
        None, // Fixed: pass temp parameter
        Some(filed),
        None,
        None,
        Some(fext),
        Some(human),
    )?;

    Ok(ConfigerContext::new(configer, clear.unwrap_or(false)))
}

/// Habitat Config File
///
/// Supports four serializations: HJSON, JSON, MGPK (MsgPack), and CBOR
/// The serialization is determined by the file extension .fext which may be
/// either '.json', '.mgpk', or '.cbor'. The default is that .json extension
/// uses HJSON because HJSON can get (load) a strict json file.
/// To use strict json on put (dump) then set .human to false.
#[derive(Debug)]
pub struct Configer {
    pub filer: Filer,
    pub human: bool,
}

impl Configer {
    // Class constants for KERI config paths
    const TAIL_DIR_PATH: &'static str = "keri/cf";
    const CLEAN_TAIL_DIR_PATH: &'static str = "keri/clean/cf";
    const ALT_TAIL_DIR_PATH: &'static str = ".keri/cf";
    const ALT_CLEAN_TAIL_DIR_PATH: &'static str = ".keri/clean/cf";
    const TEMP_PREFIX: &'static str = "keri_cf_";

    /// Setup config file at path
    ///
    /// Parameters:
    ///     name: directory path name differentiator directory/file
    ///         When system employs more than one keri installation, name allows
    ///         differentiating each instance by name
    ///     base: optional directory path segment inserted before name
    ///         that allows further differentiation with a hierarchy. "" means optional.
    ///     temp: assign to .temp
    ///         true then open in temporary directory, clear on close
    ///         Otherwise then open persistent directory, do not clear on close
    ///     head_dir_path: optional head directory pathname for main database
    ///     perm: optional numeric os dir permissions for database directory and database files
    ///     reopen: true means (re)opened by this init, false means not (re)opened by this init but later
    ///     clear: true means remove directory upon close if reopen, false means do not remove directory upon close if reopen
    ///     reuse: true means reuse self.path if already exists, false means do not reuse but remake self.path
    ///     clean: true means path uses clean tail variant, false means path uses normal tail variant
    ///     filed: true means .path is file path not directory path, false means .path is directory path not file path
    ///     mode: File open mode when filed default non-truncate r+w
    ///     fext: File extension when filed
    ///     human: true means use human friendly HJSON when fext is json
    pub fn new(
        name: Option<String>,
        base: Option<String>,
        temp: Option<bool>,
        head_dir_path: Option<PathBuf>,
        perm: Option<u32>,
        reopen: Option<bool>,
        clear: Option<bool>,
        reuse: Option<bool>,
        clean: Option<bool>,
        filed: Option<bool>,
        extensioned: Option<bool>,
        mode: Option<String>,
        fext: Option<String>,
        human: Option<bool>,
    ) -> Result<Self, HioError> {
        let name = name.unwrap_or_else(|| "conf".to_string());
        let base = base.unwrap_or_else(|| "main".to_string());
        let filed = filed.unwrap_or(true);
        let mode = mode.unwrap_or_else(|| "r+b".to_string());
        let fext = fext.unwrap_or_else(|| "json".to_string());
        let human = human.unwrap_or(true);

        // Create a Filer with custom KERI paths
        let mut filer = Filer::new(
            Some(name),
            Some(base),
            temp,
            head_dir_path.clone(),
            perm,
            Some(false), // Don't reopen yet, we need to set custom paths first
            clear,
            reuse,
            clean,
            Some(filed),
            extensioned,
            Some(mode.clone()),
            Some(fext.clone()),
        )?;

        // Override the default paths with KERI-specific paths
        filer.tail_dir_path = PathBuf::from(Self::TAIL_DIR_PATH);
        filer.clean_tail_dir_path = PathBuf::from(Self::CLEAN_TAIL_DIR_PATH);
        filer.alt_tail_dir_path = PathBuf::from(Self::ALT_TAIL_DIR_PATH);
        filer.alt_clean_tail_dir_path = PathBuf::from(Self::ALT_CLEAN_TAIL_DIR_PATH);
        filer.temp_prefix = Self::TEMP_PREFIX.to_string();

        // Now reopen with the custom paths
        if reopen.unwrap_or(true) {
            filer.reopen(
                temp,
                head_dir_path,
                perm,
                clear.unwrap_or(false),
                reuse.unwrap_or(false),
                clean.unwrap_or(false),
                Some(mode),
                Some(fext),
            )?;
        }

        Ok(Configer { filer, human })
    }

    /// Serialize data dict and write to file given by path where serialization is
    /// given by fext path's extension of either JSON, MsgPack, or CBOR for extension
    /// .json, .mgpk, or .cbor respectively
    ///
    /// Parameters:
    ///     data: to be serialized per file extension on path
    ///     human: override for human-friendly JSON formatting
    ///
    /// Raises:
    ///     HioError if unsupported file extension or file not opened
    pub fn put<T: Serialize>(&mut self, data: &T, human: Option<bool>) -> Result<bool, HioError> {
        if self.filer.file.is_none() {
            return Err(HioError::FilerError(format!(
                "File '{:?}' not opened.",
                self.filer.path
            )));
        }

        let human = human.unwrap_or(self.human);
        let file = self.filer.file.as_mut().unwrap();

        file.seek(SeekFrom::Start(0)).map_err(HioError::IoError)?;
        file.set_len(0).map_err(HioError::IoError)?; // Truncate

        let path = self.filer.path.as_ref().unwrap();
        let ext = path.extension().and_then(|s| s.to_str()).unwrap_or("");

        let serialized =
            match ext {
                "json" => {
                    if human {
                        // For human-friendly JSON, use pretty printing
                        serde_json::to_string_pretty(data)
                            .map_err(|e| HioError::SerializationError(e.to_string()))?
                            .into_bytes()
                    } else {
                        // For compact JSON
                        serde_json::to_string(data)
                            .map_err(|e| HioError::SerializationError(e.to_string()))?
                            .into_bytes()
                    }
                }
                "mgpk" => msgpack::to_vec(data)
                    .map_err(|e| HioError::SerializationError(e.to_string()))?,
                "cbor" => serde_cbor::to_vec(data)
                    .map_err(|e| HioError::SerializationError(e.to_string()))?,
                _ => {
                    return Err(HioError::FilerError(format!(
                        "Invalid file path ext '{}' not '.json', '.mgpk', or '.cbor'.",
                        ext
                    )));
                }
            };

        file.write_all(&serialized).map_err(HioError::IoError)?;
        file.flush().map_err(HioError::IoError)?;
        file.sync_all().map_err(HioError::IoError)?; // fsync equivalent

        Ok(true)
    }

    /// Returns data converted from contents of file path given extension
    /// Returns empty/default value if empty file
    ///
    /// Raises:
    ///     HioError if unsupported file extension or file not opened
    ///
    /// File may be either json, msgpack, or cbor given by extension .json, .mgpk, or
    /// .cbor respectively
    pub fn get<T>(&mut self, human: Option<bool>) -> Result<T, HioError>
    where
        T: for<'de> Deserialize<'de> + Default,
    {
        if self.filer.file.is_none() {
            return Err(HioError::FilerError(format!(
                "File '{:?}' not opened.",
                self.filer.path
            )));
        }

        let human = human.unwrap_or(self.human);
        let file = self.filer.file.as_mut().unwrap();

        file.seek(SeekFrom::Start(0)).map_err(HioError::IoError)?;
        let mut contents = Vec::new();
        file.read_to_end(&mut contents).map_err(HioError::IoError)?;

        if contents.is_empty() {
            return Ok(T::default());
        }

        let path = self.filer.path.as_ref().unwrap();
        let ext = path.extension().and_then(|s| s.to_str()).unwrap_or("");

        let data = match ext {
            "json" => {
                let text = String::from_utf8(contents)
                    .map_err(|e| HioError::SerializationError(e.to_string()))?;

                if human {
                    // Try to parse as HJSON first, fall back to regular JSON
                    // Note: We'll use regular JSON for now since hjson crate might not be available
                    // In a real implementation, you'd want to add hjson support
                    serde_json::from_str(&text)
                        .map_err(|e| HioError::SerializationError(e.to_string()))?
                } else {
                    serde_json::from_str(&text)
                        .map_err(|e| HioError::SerializationError(e.to_string()))?
                }
            }
            "mgpk" => msgpack::from_slice(&contents)
                .map_err(|e| HioError::SerializationError(e.to_string()))?,
            "cbor" => serde_cbor::from_slice(&contents)
                .map_err(|e| HioError::SerializationError(e.to_string()))?,
            _ => {
                return Err(HioError::FilerError(format!(
                    "Invalid file path ext '{}' not '.json', '.mgpk', or '.cbor'.",
                    ext
                )));
            }
        };

        Ok(data)
    }

    /// Close the configer
    pub fn close(&mut self, clear: bool) -> Result<bool, HioError> {
        self.filer.close(clear)
    }

    /// Reopen the configer
    pub fn reopen(
        &mut self,
        temp: Option<bool>,
        head_dir_path: Option<PathBuf>,
        perm: Option<u32>,
        clear: bool,
        reuse: bool,
        clean: bool,
        mode: Option<String>,
        fext: Option<String>,
    ) -> Result<bool, HioError> {
        self.filer
            .reopen(temp, head_dir_path, perm, clear, reuse, clean, mode, fext)
    }

    /// Check if config exists
    pub fn exists(
        &self,
        name: &str,
        base: &str,
        head_dir_path: Option<&Path>,
        clean: bool,
        filed: bool,
        extensioned: bool,
        fext: Option<&str>,
    ) -> Result<bool, HioError> {
        self.filer
            .exists(name, base, head_dir_path, clean, filed, extensioned, fext)
    }
}

// Delegate common properties to the underlying Filer
impl std::ops::Deref for Configer {
    type Target = Filer;
    fn deref(&self) -> &Self::Target {
        &self.filer
    }
}

impl std::ops::DerefMut for Configer {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.filer
    }
}

/// Context manager for Configer
pub struct ConfigerContext {
    pub configer: Configer,
    clear_on_drop: bool,
}

impl ConfigerContext {
    pub fn new(configer: Configer, clear: bool) -> Self {
        let clear_on_drop = configer.filer.temp || clear;
        Self {
            configer,
            clear_on_drop,
        }
    }
}

impl Drop for ConfigerContext {
    fn drop(&mut self) {
        let _ = self.configer.close(self.clear_on_drop);
    }
}

impl std::ops::Deref for ConfigerContext {
    type Target = Configer;
    fn deref(&self) -> &Self::Target {
        &self.configer
    }
}

impl std::ops::DerefMut for ConfigerContext {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.configer
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde::{Deserialize, Serialize};
    use std::collections::HashMap;
    use std::io::{Read, Seek, SeekFrom, Write};
    use std::sync::Mutex;

    // Force tests to run sequentially to avoid race conditions
    static TEST_MUTEX: Mutex<()> = Mutex::new(());

    fn with_test_lock<F, R>(f: F) -> R
    where
        F: FnOnce() -> R,
    {
        // Handle poisoned mutex by ignoring the poison and continuing
        let _guard = match TEST_MUTEX.lock() {
            Ok(guard) => guard,
            Err(poisoned) => {
                eprintln!("Test mutex was poisoned, recovering...");
                poisoned.into_inner()
            }
        };
        f()
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq, Default)]
    struct TestConfig {
        dt: String,
        nel: TestNel,
        iurls: Vec<String>,
        durls: Vec<String>,
        wurls: Vec<String>,
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq, Default)]
    struct TestNel {
        dt: String,
        curls: Vec<String>,
    }

    fn cleanup_test_dirs() {
        // Clean up test directories
        let dirs_to_clean = vec!["/usr/local/var/keri"];

        for dir in dirs_to_clean {
            let path = PathBuf::from(dir);
            if path.exists() {
                let _ = std::fs::remove_dir_all(&path);
            }
        }

        if let Some(home) = dirs::home_dir() {
            let alt_dirs = vec![home.join(".keri")];

            for dir in alt_dirs {
                if dir.exists() {
                    let _ = std::fs::remove_dir_all(&dir);
                }
            }
        }

        // Small delay to ensure filesystem operations complete
        std::thread::sleep(std::time::Duration::from_millis(10));
    }

    #[test]
    fn test_configer() -> Result<(), HioError> {
        with_test_lock(|| {
            cleanup_test_dirs();

            // Test Configer with defaults
            let filepath = "/usr/local/var/keri/cf/main/conf.json";
            if PathBuf::from(filepath).exists() {
                std::fs::remove_file(filepath).ok();
            }

            let mut cfr = Configer::new(
                None, None, None, None, None, None, None, None, None, None, None, None, None, None,
            )?; // defaults

            // assert cfr.path == filepath
            // github runner does not allow /usr/local/var
            assert!(cfr
                .path
                .as_ref()
                .unwrap()
                .to_string_lossy()
                .ends_with("keri/cf/main/conf.json"));
            assert!(cfr.opened);
            assert!(cfr.path.as_ref().unwrap().exists());
            assert!(cfr.file.is_some());
            assert!(cfr.human);

            // Test empty file read
            let empty_data: HashMap<String, String> = cfr.get(None)?;
            assert!(empty_data.is_empty());

            // Plain json manually (simulating direct file operations)
            let data = HashMap::from([
                ("name".to_string(), "habi".to_string()),
                ("oobi".to_string(), "ABCDEFG".to_string()),
            ]);

            // Test put/get with HJSON (human=true)
            let wdata = HashMap::from([
                ("name".to_string(), "hope".to_string()),
                ("oobi".to_string(), "abc".to_string()),
            ]);

            assert!(cfr.put(&wdata, None)?);
            let rdata: HashMap<String, String> = cfr.get(None)?;
            assert_eq!(rdata, wdata);

            // Verify human-readable format by reading raw file content
            if let Some(ref mut file) = cfr.file {
                file.seek(SeekFrom::Start(0)).unwrap();
                let mut contents = String::new();
                file.read_to_string(&mut contents).unwrap();
                // Should be pretty-printed JSON (human-readable)
                assert!(contents.contains("{\n"));
                assert!(contents.contains("  \""));
            }

            cfr.close(false)?;
            assert!(!cfr.opened);
            assert!(cfr
                .path
                .as_ref()
                .unwrap()
                .to_string_lossy()
                .ends_with("keri/cf/main/conf.json"));
            assert!(cfr.path.as_ref().unwrap().exists());

            // Should error when trying to get from closed file
            let result: Result<HashMap<String, String>, _> = cfr.get(None);
            assert!(matches!(result, Err(HioError::FilerError(_))));

            // Test reopen with reuse=true
            cfr.reopen(None, None, None, false, true, false, None, None)?;
            assert!(cfr.opened);
            assert!(cfr
                .path
                .as_ref()
                .unwrap()
                .to_string_lossy()
                .ends_with("keri/cf/main/conf.json"));
            assert!(cfr.path.as_ref().unwrap().exists());
            let rdata: HashMap<String, String> = cfr.get(None)?;
            assert_eq!(rdata, wdata); // not empty

            // Test reopen without reuse (remake but not clear)
            cfr.reopen(None, None, None, false, false, false, None, None)?;
            assert!(cfr.opened);
            assert!(cfr
                .path
                .as_ref()
                .unwrap()
                .to_string_lossy()
                .ends_with("keri/cf/main/conf.json"));
            assert!(cfr.path.as_ref().unwrap().exists());
            let rdata: HashMap<String, String> = cfr.get(None)?;
            assert_eq!(rdata, wdata); // not empty

            // Test reopen with reuse=true, clear=true (should remake even with reuse)
            cfr.reopen(None, None, None, true, true, false, None, None)?;
            assert!(cfr.opened);
            assert!(cfr
                .path
                .as_ref()
                .unwrap()
                .to_string_lossy()
                .ends_with("keri/cf/main/conf.json"));
            assert!(cfr.path.as_ref().unwrap().exists());
            let rdata: HashMap<String, String> = cfr.get(None)?;
            assert!(rdata.is_empty()); // empty due to clear

            let wdata = HashMap::from([
                ("name".to_string(), "hope".to_string()),
                ("oobi".to_string(), "abc".to_string()),
            ]);
            assert!(cfr.put(&wdata, None)?);
            let rdata: HashMap<String, String> = cfr.get(None)?;
            assert_eq!(rdata, wdata);

            // Test reopen with clear=true (should remake)
            cfr.reopen(None, None, None, true, false, false, None, None)?;
            assert!(cfr.opened);
            assert!(cfr
                .path
                .as_ref()
                .unwrap()
                .to_string_lossy()
                .ends_with("keri/cf/main/conf.json"));
            assert!(cfr.path.as_ref().unwrap().exists());
            let rdata: HashMap<String, String> = cfr.get(None)?;
            assert!(rdata.is_empty()); // empty

            let wdata = HashMap::from([
                ("name".to_string(), "hope".to_string()),
                ("oobi".to_string(), "abc".to_string()),
            ]);
            assert!(cfr.put(&wdata, None)?);
            let rdata: HashMap<String, String> = cfr.get(None)?;
            assert_eq!(rdata, wdata);

            cfr.close(true)?;
            assert!(!cfr.path.as_ref().unwrap().exists());
            let result: Result<HashMap<String, String>, _> = cfr.get(None);
            assert!(matches!(result, Err(HioError::FilerError(_))));

            cleanup_test_dirs();
            Ok(())
        })
    }

    #[test]
    fn test_configer_human_false() -> Result<(), HioError> {
        with_test_lock(|| {
            cleanup_test_dirs();

            // Test with plain json human==false
            let mut cfr = Configer::new(
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                Some(false), // human=false
            )?;

            assert!(cfr
                .path
                .as_ref()
                .unwrap()
                .to_string_lossy()
                .ends_with("keri/cf/main/conf.json"));
            assert!(cfr.opened);
            assert!(cfr.path.as_ref().unwrap().exists());
            assert!(cfr.file.is_some());
            assert!(!cfr.human);

            let empty_data: HashMap<String, String> = cfr.get(None)?;
            assert!(empty_data.is_empty());

            // Test with human==false
            let wdata = HashMap::from([
                ("name".to_string(), "hope".to_string()),
                ("oobi".to_string(), "abc".to_string()),
            ]);
            assert!(cfr.put(&wdata, None)?);
            let rdata: HashMap<String, String> = cfr.get(None)?;
            assert_eq!(rdata, wdata);

            // Verify compact JSON format by reading raw file content
            if let Some(ref mut file) = cfr.file {
                file.seek(SeekFrom::Start(0)).unwrap();
                let mut contents = String::new();
                file.read_to_string(&mut contents).unwrap();
                // Should contain JSON structure - compact format without pretty printing
                assert!(contents.contains("\"name\""));
                assert!(contents.contains("\"hope\""));
                assert!(contents.contains("\"oobi\""));
                assert!(contents.contains("\"abc\""));
                // For compact JSON, it should NOT contain newlines and indentation
                assert!(!contents.contains("{\n"));
                assert!(!contents.contains("  \""));
                // But should still be valid JSON in one line
                assert!(contents.starts_with('{'));
                assert!(contents.ends_with('}'));
            }

            cfr.close(true)?;
            assert!(!cfr.path.as_ref().unwrap().exists());

            cleanup_test_dirs();
            Ok(())
        })
    }

    #[test]
    fn test_configer_alt_path() -> Result<(), HioError> {
        with_test_lock(|| {
            cleanup_test_dirs();

            // Test with altPath by using not permitted headDirPath to force Alt
            let restricted_head = PathBuf::from("/root/keri");

            let mut cfr = Configer::new(
                None,
                None,
                None,
                Some(restricted_head), // This should force alt path
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
            )?;

            assert!(cfr
                .path
                .as_ref()
                .unwrap()
                .to_string_lossy()
                .contains(".keri/cf/main/conf.json"));
            assert!(cfr.opened);
            assert!(cfr.path.as_ref().unwrap().exists());
            assert!(cfr.file.is_some());

            let empty_data: HashMap<String, String> = cfr.get(None)?;
            assert!(empty_data.is_empty());

            let data = HashMap::from([
                ("name".to_string(), "habi".to_string()),
                ("oobi".to_string(), "ABCDEFG".to_string()),
            ]);

            // Test put/get
            let wdata = HashMap::from([
                ("name".to_string(), "hope".to_string()),
                ("oobi".to_string(), "abc".to_string()),
            ]);
            assert!(cfr.put(&wdata, None)?);
            let rdata: HashMap<String, String> = cfr.get(None)?;
            assert_eq!(rdata, wdata);

            cfr.close(false)?;
            assert!(!cfr.opened);
            assert!(cfr
                .path
                .as_ref()
                .unwrap()
                .to_string_lossy()
                .contains(".keri/cf/main/conf.json"));
            assert!(cfr.path.as_ref().unwrap().exists());
            let result: Result<HashMap<String, String>, _> = cfr.get(None);
            assert!(matches!(result, Err(HioError::FilerError(_))));

            // Test various reopen scenarios
            cfr.reopen(None, None, None, false, true, false, None, None)?;
            assert!(cfr.opened);
            assert!(cfr
                .path
                .as_ref()
                .unwrap()
                .to_string_lossy()
                .contains(".keri/cf/main/conf.json"));
            assert!(cfr.path.as_ref().unwrap().exists());
            let rdata: HashMap<String, String> = cfr.get(None)?;
            assert_eq!(rdata, wdata); // not empty

            cfr.reopen(None, None, None, false, false, false, None, None)?;
            assert!(cfr.opened);
            assert!(cfr
                .path
                .as_ref()
                .unwrap()
                .to_string_lossy()
                .contains(".keri/cf/main/conf.json"));
            assert!(cfr.path.as_ref().unwrap().exists());
            let rdata: HashMap<String, String> = cfr.get(None)?;
            assert_eq!(rdata, wdata); // not empty

            cfr.reopen(None, None, None, true, true, false, None, None)?;
            assert!(cfr.opened);
            assert!(cfr
                .path
                .as_ref()
                .unwrap()
                .to_string_lossy()
                .contains(".keri/cf/main/conf.json"));
            assert!(cfr.path.as_ref().unwrap().exists());
            let rdata: HashMap<String, String> = cfr.get(None)?;
            assert!(rdata.is_empty()); // empty

            let wdata = HashMap::from([
                ("name".to_string(), "hope".to_string()),
                ("oobi".to_string(), "abc".to_string()),
            ]);
            assert!(cfr.put(&wdata, None)?);
            let rdata: HashMap<String, String> = cfr.get(None)?;
            assert_eq!(rdata, wdata);

            cfr.reopen(None, None, None, true, false, false, None, None)?;
            assert!(cfr.opened);
            assert!(cfr
                .path
                .as_ref()
                .unwrap()
                .to_string_lossy()
                .contains(".keri/cf/main/conf.json"));
            assert!(cfr.path.as_ref().unwrap().exists());
            let rdata: HashMap<String, String> = cfr.get(None)?;
            assert!(rdata.is_empty()); // empty

            let wdata = HashMap::from([
                ("name".to_string(), "hope".to_string()),
                ("oobi".to_string(), "abc".to_string()),
            ]);
            assert!(cfr.put(&wdata, None)?);
            let rdata: HashMap<String, String> = cfr.get(None)?;
            assert_eq!(rdata, wdata);

            cfr.close(true)?;
            assert!(!cfr.path.as_ref().unwrap().exists());
            let result: Result<HashMap<String, String>, _> = cfr.get(None);
            assert!(matches!(result, Err(HioError::FilerError(_))));

            cleanup_test_dirs();
            Ok(())
        })
    }

    #[test]
    fn test_open_cf_context_hjson() -> Result<(), HioError> {
        with_test_lock(|| {
            // Test openCF hjson (default uses json and temp==true)
            {
                let mut cfr = open_cf(
                    Some("test".to_string()),
                    Some(true), // temp
                    None,
                    None,
                    None,
                    None,
                    None,
                    Some(true), // human
                )?;

                let temp_dir = std::env::temp_dir();
                assert!(cfr
                    .path
                    .as_ref()
                    .unwrap()
                    .to_string_lossy()
                    .contains("keri_"));
                assert!(cfr
                    .path
                    .as_ref()
                    .unwrap()
                    .to_string_lossy()
                    .contains("_test/keri/cf/main/test.json"));
                assert!(cfr.opened);
                assert!(cfr.human);
                assert!(cfr.path.as_ref().unwrap().exists());
                assert!(cfr.file.is_some());

                let wdata = HashMap::from([
                    ("name".to_string(), "hope".to_string()),
                    ("oobi".to_string(), "abc".to_string()),
                ]);
                assert!(cfr.put(&wdata, None)?);
                let rdata: HashMap<String, String> = cfr.get(None)?;
                assert_eq!(rdata, wdata);
            } // cfr goes out of scope, should clean temp files

            Ok(())
        })
    }

    #[test]
    fn test_open_cf_context_json() -> Result<(), HioError> {
        with_test_lock(|| {
            // Test openCF json (human=false)
            {
                let mut cfr = open_cf(
                    Some("test".to_string()),
                    Some(true), // temp
                    None,
                    None,
                    None,
                    None,
                    None,
                    Some(false), // human=false
                )?;

                assert!(cfr
                    .path
                    .as_ref()
                    .unwrap()
                    .to_string_lossy()
                    .contains("keri_"));
                assert!(cfr
                    .path
                    .as_ref()
                    .unwrap()
                    .to_string_lossy()
                    .contains("_test/keri/cf/main/test.json"));
                assert!(cfr.opened);
                assert!(!cfr.human);
                assert!(cfr.path.as_ref().unwrap().exists());
                assert!(cfr.file.is_some());

                let wdata = HashMap::from([
                    ("name".to_string(), "hope".to_string()),
                    ("oobi".to_string(), "abc".to_string()),
                ]);
                assert!(cfr.put(&wdata, None)?);
                let rdata: HashMap<String, String> = cfr.get(None)?;
                assert_eq!(rdata, wdata);
            } // should clean temp files

            Ok(())
        })
    }

    #[test]
    fn test_open_cf_context_msgpack() -> Result<(), HioError> {
        with_test_lock(|| {
            // Test openCF mgpk
            {
                let mut cfr = open_cf(
                    Some("test".to_string()),
                    Some(true), // temp
                    None,
                    None,
                    None,
                    None,
                    Some("mgpk".to_string()),
                    None,
                )?;

                assert!(cfr
                    .path
                    .as_ref()
                    .unwrap()
                    .to_string_lossy()
                    .contains("keri_"));
                assert!(cfr
                    .path
                    .as_ref()
                    .unwrap()
                    .to_string_lossy()
                    .contains("_test/keri/cf/main/test.mgpk"));
                assert!(cfr.opened);
                assert!(cfr.path.as_ref().unwrap().exists());
                assert!(cfr.file.is_some());

                let wdata = HashMap::from([
                    ("name".to_string(), "hope".to_string()),
                    ("oobi".to_string(), "abc".to_string()),
                ]);
                assert!(cfr.put(&wdata, None)?);
                let rdata: HashMap<String, String> = cfr.get(None)?;
                assert_eq!(rdata, wdata);
            } // should clean temp files

            Ok(())
        })
    }

    #[test]
    fn test_open_cf_context_cbor() -> Result<(), HioError> {
        with_test_lock(|| {
            // Test openCF cbor
            {
                let mut cfr = open_cf(
                    Some("test".to_string()),
                    Some(true), // temp
                    None,
                    None,
                    None,
                    None,
                    Some("cbor".to_string()),
                    None,
                )?;

                assert!(cfr
                    .path
                    .as_ref()
                    .unwrap()
                    .to_string_lossy()
                    .contains("keri_"));
                assert!(cfr
                    .path
                    .as_ref()
                    .unwrap()
                    .to_string_lossy()
                    .contains("_test/keri/cf/main/test.cbor"));
                assert!(cfr.opened);
                assert!(cfr.path.as_ref().unwrap().exists());
                assert!(cfr.file.is_some());

                let wdata = HashMap::from([
                    ("name".to_string(), "hope".to_string()),
                    ("oobi".to_string(), "abc".to_string()),
                ]);
                assert!(cfr.put(&wdata, None)?);
                let rdata: HashMap<String, String> = cfr.get(None)?;
                assert_eq!(rdata, wdata);
            } // should clean temp files

            Ok(())
        })
    }
    #[test]
    fn test_configer_error_cases() -> Result<(), HioError> {
        with_test_lock(|| {
            cleanup_test_dirs();

            // Test that invalid extension causes an error during put/get operations
            let mut cfr = Configer::new(
                Some("test_invalid".to_string()),
                Some("test".to_string()),
                Some(true), // temp
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                Some("invalid".to_string()), // Use invalid extension directly
                None,
            )?;

            // Put some test data to the file first so it's not empty
            let test_data: HashMap<String, String> =
                HashMap::from([("key".to_string(), "value".to_string())]);

            // Both put and get should fail with invalid extension
            let put_result = cfr.put(&test_data, None);
            assert!(matches!(put_result, Err(HioError::FilerError(_))));

            // Since put failed, the file should still be empty, but let's test get anyway
            // We need to put some invalid content in the file first to avoid the empty file shortcut
            if let Some(ref mut file) = cfr.file {
                use std::io::Write;
                file.seek(SeekFrom::Start(0)).unwrap();
                file.write_all(b"invalid content").unwrap();
                file.flush().unwrap();
            }

            let get_result: Result<HashMap<String, String>, _> = cfr.get(None);
            assert!(matches!(get_result, Err(HioError::FilerError(_))));

            cfr.close(true)?;
            cleanup_test_dirs();
            Ok(())
        })
    }

    #[test]
    fn test_configer_different_formats() -> Result<(), HioError> {
        with_test_lock(|| {
            // Test data structure - add Default implementation
            #[derive(Debug, Serialize, Deserialize, PartialEq, Default)]
            struct ComplexData {
                name: String,
                oobi: String,
                numbers: Vec<i32>,
                nested: HashMap<String, String>,
            }

            let test_data = ComplexData {
                name: "test".to_string(),
                oobi: "ABCDEFG".to_string(),
                numbers: vec![1, 2, 3, 4, 5],
                nested: HashMap::from([
                    ("key1".to_string(), "value1".to_string()),
                    ("key2".to_string(), "value2".to_string()),
                ]),
            };

            // Test JSON
            {
                let mut cfr = Configer::new(
                    Some("test_complex_json".to_string()),
                    None,
                    Some(true),
                    None,
                    None,
                    None,
                    None,
                    None,
                    None,
                    None,
                    None,
                    None,
                    Some("json".to_string()),
                    Some(true),
                )?;
                cfr.put(&test_data, None)?;
                let retrieved: ComplexData = cfr.get(None)?;
                assert_eq!(test_data, retrieved);
            }

            // Test MessagePack
            {
                let mut cfr = Configer::new(
                    Some("test_complex_mgpk".to_string()),
                    None,
                    Some(true),
                    None,
                    None,
                    None,
                    None,
                    None,
                    None,
                    None,
                    None,
                    None,
                    Some("mgpk".to_string()),
                    None,
                )?;
                cfr.put(&test_data, None)?;
                let retrieved: ComplexData = cfr.get(None)?;
                assert_eq!(test_data, retrieved);
            }

            // Test CBOR
            {
                let mut cfr = Configer::new(
                    Some("test_complex_cbor".to_string()),
                    None,
                    Some(true),
                    None,
                    None,
                    None,
                    None,
                    None,
                    None,
                    None,
                    None,
                    None,
                    Some("cbor".to_string()),
                    None,
                )?;
                cfr.put(&test_data, None)?;
                let retrieved: ComplexData = cfr.get(None)?;
                assert_eq!(test_data, retrieved);
            }

            Ok(())
        })
    }
}
